Questão 1:
#include <iostream>
#include <string>
using namespace std;

void bubbleSort(string &str) {
    int n = str.length();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (str[j] > str[j + 1]) {
                swap(str[j], str[j + 1]);
            }
        }
    }
}

int main() {
    string input;

    cout << "Digite uma string: ";
    getline(cin, input);

    bubbleSort(input);

    cout << "String ordenada: " << input << endl;

    return 0;
}

Questão 2:
#include <iostream>
#include <string>
#include <vector>
using namespace std;

void selectionSort(vector<string> &nomes) {
    int n = nomes.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (nomes[j].length() < nomes[minIndex].length()) {
                minIndex = j;
            }
        }
       
        swap(nomes[i], nomes[minIndex]);
    }
}

int main() {
    int n;
    cout << "Digite o número de nomes: ";
    cin >> n;
    cin.ignore(); 

    vector<string> nomes(n);

    cout << "Digite os nomes:\n";
    for (int i = 0; i < n; i++) {
        getline(cin, nomes[i]);
    }
    
    selectionSort(nomes);

    cout << "Nomes ordenados pelo tamanho:\n";
    for (const string &nome : nomes) {
        cout << nome << endl;
    }

    return 0;
}

Questão 3:
Essas mudanças podem ser úteis para analise de desempenho de algoritimos.

#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(int arr[], int n, vector<pair<int, int>> &trocas) {
    bool trocou;
    for (int i = 0; i < n - 1; i++) {
        trocou = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                trocas.push_back({j, j + 1});
                trocou = true;
            }
        }
        if (!trocou) {
            break;
        }
    }
}

int main() {
    int n;
    cout << "Digite o número de elementos: ";
    cin >> n;

    int arr[n];
    cout << "Digite os elementos:\n";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    vector<pair<int, int>> trocas;

    bubbleSort(arr, n, trocas);

    cout << "Vetor ordenado:\n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    cout << "Trocas realizadas (posição1, posição2):\n";
    for (const auto &troca : trocas) {
        cout << "(" << troca.first << ", " << troca.second << ")\n";
    }

    return 0;
}

Questão 4:
Quando falamos do Insertion Sort com Busca sequencial 
- Em seu melhor caso ele irá possuir O(n) comparações e 0 trocas 
- Em um caso médio teremos por volta de O(n^2) comparações e por volta de O(n^2) trocas
- Em seu pior caso teremos O(n^2) comparações e O(n^2) trocas

No Insertion Sort com Busca binária
- Em seu melhor caso ele irá realizar O(n) comparaçõs e 0 trocas
- Em seus casos medianos ele irá realizar por volta de O(n^2) trocas e por volta de O(n^2) comparações
- Em seu pior caso ele irá realizar O(n^2) comparações e O(n^2) trocas

Assim podemos concluir que o desempenho de ambos os métodos é extremamente parecido, se não idêntico.

Questão 5:
#include <iostream>
using namespace std;

void selectionSortMaior(int arr[], int n) {
    for (int i = n - 1; i > 0; i--) {
        int maxIndex = 0;
        for (int j = 1; j <= i; j++) {
            if (arr[j] > arr[maxIndex]) {
                maxIndex = j;
            }
        }
        swap(arr[maxIndex], arr[i]);
    }
}

int main() {
    int n;
    cout << "Digite o número de elementos: ";
    cin >> n;

    int arr[n];
    cout << "Digite os elementos:\n";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    selectionSortMaior(arr, n);

    cout << "Array ordenado:\n";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}

Questão 6:


Questão 7:


Questão 8:


Questão 9:


Parte prática C++

Questão 1:

Questão 2:

Questão 3:

Questão 4:
